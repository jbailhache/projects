<html>
<head>
<title>Proof Logic</title>
</head>
<body>
<h2>Proof Logic</h2>
Proof Logic is a formalism for representing proofs in formal systems.
A proof is an expression that proves the truth of a sentence in a given formal system, which is a formalization of a theory.
In Proof Logic, a sentence is an equality between two terms.
Proof Logic expressions are both terms and proofs.
This does not mean that some Proof Logic expression are terms and other are proofs, but that ANY Proof Logic expression is BOTH a term and a proof. 
A term "x" is identified with the proof of the sentence "x = x".
Proof Logic expressions are called "proofs".
<p>
Proof Logic is a functional formalism, like Combinatory Logic and lambda Calculus.
It uses <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn index</a> to represent variables.
As in Combinatory Logic and Lambda Calculus, the application of a function "f" to an argument "a" is denoted "f a", and "(f a) b" may be written more simply "f a b" which means : first apply f to a, and then apply the resulting function to b. But if we want to apply a function f to an argument a, and then apply another function g to the result, we must write it "g (f a)". It may also be written "g : f a". The ":" is like a "(" with an implicit corresponding ")". 
<p>
A function with one variable is represented by an expression of the form "[ ... * ... * ... ]" where "*" represents the variable (which may appear with 0, 1, or several occurences).
For example, a function applying its argument to itself is written "[ * * ]" and when we apply it to an argument "a" we have the equality " [ * * ] a = a a ".
A function with two variables is represented by a function with one variable giving, when applyed to a first argument, another function with one variable giving, when applied to the second argument, the final result. Such a function is written "[[ ... '* ... * ... ]]" where " '* " will be replaced by the first argument and " * " will be replaced by the second argument.
So " * " corresponds to " 1 " in De Bruijn's index, " '* " to " 2 ", " ''* " to " 3 ", and so on.
<p>
At this point, the formalism is equivalent to Lambda Calculus or Combinatory Logic.
We will now extend it.
<p>
First, we will add symbols. A symbol, which is a member of a set of symbols, which can be chosen either as finite, but as big as needed, or infinite but countable. A symbol is represented by a sequence of letter, digits, and eventually some special characters like "_" which are not used for anything else.
<p>
We have seen that Proof Logic expressions represent proofs. The simplest proofs of a formal system are the axioms of the system. Since sentences of Proof Logic are equalities, an axiom has the form "a = b". So the Proof Logic expression (or the proof) "a = b" represents the axioms asserting the equality between a and b. Of course, the operator "=" may be used only in axioms, otherwise we could prove anything !
<p>
Any Proof Logic expression may be seen as a proof which proves the truth of a sentence (the conclusion of the proof) which is an equality between two terms, which are also Proof Logic expressions. Given any Proof Logic expression x, we can determine which equality it proves. More precisely, there are two computable functions called "left" and "right", computing the terms of the equality proved by the given proof : x proves left(x) = right(x).
For example, we have left(a = b) = a and right(a = b) = b, so a = b proves left(a = b) = right(a = b) or a = b proves a = b.
<p>
In theories based on equality, there are often 3 axioms representing the properties of equality : reflexivity (a = a), symmetry (a = b => b = a) and transitivity (a = b & b = c => a = c).
In Proof Logic, a reflexivity axiom is useless because, as we have seen, any term a is also the proof of the sentence "a = a". Symmetry and transitivity are merged into one property of "transymmetry" with two possible variants : left transymmetry (a = b, a = c => b = c) and right transymmetry (a = c, b = c => a = b). <!-- We will use left transymmetry. -->
<p>
We must also be able to prove the equality between an expression and its reduced form, for example " [* *] a = a a ".
We could introduce a special operator for this, but we will rather modify the transymmetry, saying, for left transymmetry, that if a = b, and c = d, and a reduces to e, and c reduces to e, then b = d. This operator will be called "left transymmetry with reduction".
It is written " {x,y} ". If x proves a = b, and y proves c = d, and a reduces to e, and c reduces to e, then {x,y} proves b = d.
Similarly for right transymmetry, if a = b, and c = d, and b reduces to e, and d reduces to e, then a = c. This operator will be called "right transymmetry with reduction" and is written " &lt;x,y> ". It is not necessary to have both left and right transymmetry with reduction, but it may be useful.
<p>
It is also useful to have an operator doing one step of reduction, to be able to prove that red1(a) = a, where red1 does one step of reduction, or more generally, if a = b then red1(a) = b. This operator is written "/". If x proves a = b, then /x proves red1(a) = b. We can also introduce the symmetrical operator "\" : if x proves a = b, then \x proves a = red1(b).
<p>
A last useful operator is the reduction operator written "@" which reduces its argument. We will see later that it is useful principally to implement a notation for definitions.
<p>
In summary, a proof may be :
<ul>
<li> A symbol
<li> * (the variable)
<li> 'x where x is a proof 
<li> [x] where x is a proof
<li> @x where x is a proof
<li> /x where x is a proof
<li> \x where x is a proof
<li> x y (application) where x and y are proofs
<li> {x,y} <!-- or LTR x y (left transsymetry with reduction) --> where x and y are proofs
<li> &lt;x,y> where x and y are proofs
<li> x=y (axiom) where x and y are proofs
</ul>

The left and right terms of the conclusion of a proof are defined as follows :
<ul>
<li> If x is a symbol or the variable "*", then left(x) = x and right(x) = x, which means that x proves x = x.
<li> left('x) = 'left(x) ; right('x) = 'right(x)
<li> left([x]) = [left(x)] ; right([x]) = [right(x)]
<li> left(@x) = left(red(x)) ; right(@x) = right(red(x))
<li> left(/x) = red1(left(x)) ; right(/x) = right(x)
<li> left(\x) = left(x) ; right(\x) = red(right(x))
<li> left(x y) = left(x) left(y) ; right(x y) = right(x) right(y), which means that if x proves a = b and y proves c = d then x y proves a c = b d.
<li> left({x,y}) = right(x) and right({x,y}) = right(y) if left(x) and left(y) reduce to a same term, otherwise left({x,y}) = right({x,y}) = {x,y}
<li> left(&lt;x,y>) = left(x) and right(&lt;x,y>) = left(y) if right(x) and right(y) reduce to the same term, otherwise left(&lt;x,y>) = right(&lt;x,y>) = &lt;x,y>
<li> left(a=b) = a ; right(a=b) = b
</ul>

These operators (except the last one which expresses the axiom a=b) can be seen as logical rules, where x proves a = b and y proves c = d :
<ul>
<li> s : |- s = s ; * : |- * = *
<li> ' : a = b |- 'a = 'b
<li> [] : a = b |- [a] = [b] 
<li> / : a = b |- red1(a) = b
<li> \ : a = b |- a = red1(b)
<li> () : a = b, c = d |- a c = b d
<li> {,} : a = b, c = d, red(a) = red(c) |- b = d
<li> &lt;,> : a = b, c = d, red(b) = red(d) |- a = c
</ul>

The operator "@" is more difficult to express in terms of logical rules because the definition of left(@x) and right(@x) does not involve left(x) and right(x). Perhaps we could write something like :

<ul>
<li> @ : x |- left(red(x)) = right(red(x))
</ul>

We also need a notation to write a definition, to give a name to a proof and then use this name in other proofs instead of writing its full definition each time we need to use it. This is written "! name definition proof" which means "replace name by definition in proof". It is similar to "let name = definition in proof" in Haskell. The reduction operator "@" written "RED" in Haskell is required to implement this notation, as you can see in the Haskell code below : 
<pre>
 pl1 ('!' : s) = let (x, t) = pl1 s in case x of SMB x1 -> let (y, u) = pl1 t in let (z, v) = pl1 u in (RED (APL (lambda x1 z) y), v) 
</pre>
Without definitions, the reduction operator "@" would not be necessary.

<p>

De Bruijn index is efficient and theoretically satisfying, but resulting expressions are not always easily writeable and readable. 
So it could be useful to write expression with named variables like in Lambda Calculus, and convert them into De Bruijn index.
The notation "^x y" represents a proof obtained by "abstracting" from y the symbol x (playing the role of a Lambda Calculus variable).
For example, the identity function may be represented either by "^x x" or by "[*]".

<p>

We saw that in Proof Logic, all sentences are equality.
But how can we represent a sentence that is not an equality ?
A possible convention is to represent the truth of a sentence by the equality with a given term, for example the identity [*].
With this convention, the implication can be represented by application, and we get automatically the Modus Ponens rule : if p q = [*] and p = [*] then q = [*].

<p>

Here is an example of a formal system with one rule saying that if x is parent of y and y is parent of z, then x is grand parent of z, and two axioms saying that Allan is parent of Brenda and Brenda is parent of Charles :

<pre>
! gpRule1
 ^x ^y ^z ((parent x y : parent y z : grandparent x z) = [*])

! gpAxiom1 ((parent allan brenda) = [*])

! gpAxiom2 ((parent brenda charles) = [*])

! gpTheorem1
 { grandparent allan charles ,
   { gpAxiom2 (grandparent allan charles),
     { gpAxiom1 (parent brenda charles : grandparent allan charles),
       (gpRule1 allan brenda charles) } } }

gpTheorem1
</pre>

A Haskell implementation of Proof Logic gives the following result with this proof :

<pre>
PL> run "grandparent.prf"

The proof
  @[@[@[@[*] { grandparent allan charles ,
             { * (grandparent allan charles) ,
               { '* (parent brenda charles (grandparent allan charles)) ,
                 ''* allan brenda charles } } }] (parent brenda charles = [*])] (parent allan brenda = [*])] [[[(parent ''* '* (parent '* * (grandparent ''* *)) = [*])]]]
proves
  grandparent allan charles
= [*]
</pre>

Here is a proof file "skk.prf" proving the Combinatory Logic equality "S K K = I" :

<pre>
! DI (I = ^a a)
! DK (K = ^a ^b a)
! DS (S = ^a ^b ^c (a c (b c)))
{ { (DS DK DK) , S K K } , { DI , I } }
</pre>

The conclusion of this proof is "S K K = I" :

<pre>
PL> run "skk.prf"

The proof
  @[@[@[{ { * '* '* ,
          S K K } ,
        { ''* ,
          I } }] (S = [[[''* * ('* *)]]])] (K = [['*]])] (I = [*])
proves
  S K K
= I
</pre>

Here is a proof of p => p in propositional logic :

<pre>
# Proof of p => p

# Axioms
! MP ^p ^q ((imp p q) (p q) = [*])
! AK ^p ^q (imp p (imp q p) = [*])
! AS ^p ^q ^r (imp (imp p (imp q r)) (imp (imp p q) (imp p r)) = [*])
! EFQ ^p (imp false p = [*])
! RAA ^p (imp (imp (imp p false) false) p = [*])
! GEN ^p (p (all ^x p) = [*])
! PART ^p ^t (imp (all p) (p t) = [*])
! PERMUT ^p ^q (imp (all ^x  : imp p (q x)) (imp p (all q)) = [*])
! SOME ^p (imp (imp (all p) false) 
                   (imp (p (some ^x (imp (p x) false))) false)
               = [*])

# Proof

! lemma1 (AS p (imp p p) p)

! lemma2 (AK p (imp p p))

! lemma3 (MP (imp p (imp (imp p p) p))
               (imp (imp p (imp p p)) (imp p p)))

! lemma4 ( lemma1 ( (imp p (imp (imp p p) p))
                      (imp (imp p (imp p p)) (imp p p)) ) )

! lemma5 { lemma4 , lemma3 }

! lemma6 ( lemma2 
              (imp 
               (imp p (imp p p))
               (imp p p) ) )

! lemma7 { lemma6 , lemma5 }

! lemma8 (AK p p)

! lemma9 
 (MP 
    (imp p (imp p p))
    (imp p p) )

! lemma10 (lemma7 ((imp p (imp p p)) (imp p p)))

! lemma11 { lemma10 , lemma9 }

! lemma12 (lemma8 (imp p p))

! theorem1 { imp p p ,  { lemma12 , lemma11 } }

theorem1
</pre>

We can see that it effectively proves "p => p" (which is written "imp p p") :

<pre>
PL> run "prop.prf"

The proof
  @[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[*] { imp p p ,
                                                   { * ,
                                                     '* } }] ('''* (imp p p))] { * ,
                                                                                 '* }] (''* (imp p (imp p p) (imp p p)))] (''''''''''''''''* (imp p (imp p p)) (imp p p))] (''''''''''''''* p p)] { * ,
                                                                                                                                                                                                    '* }] ('''* (imp (imp p (imp p p)) (imp p p)))] { * ,
                                                                                                                                                                                                                                                      '* }] (''* (imp p (imp (imp p p) p) (imp (imp p (imp p p)) (imp p p))))] (''''''''''* (imp p (imp (imp p p) p)) (imp (imp p (imp p p)) (imp p p)))] (''''''''* p (imp p p))] (''''''* p (imp p p) p)] [(imp (imp (all *) false) (imp (* (some [imp ('* *) false])) false) = [*])]] [[(imp (all [:] imp '* (* x)) (imp '* (all *)) = [*])]]] [[(imp (all '*) ('* *) = [*])]]] [(* (all ['*]) = [*])]] [(imp (imp (imp * false) false) * = [*])]] [(imp false * = [*])]] [[[(imp (imp ''* (imp '* *)) (imp (imp ''* '*) (imp ''* *)) = [*])]]]] [[(imp '* (imp * '*) = [*])]]] [[(imp '* * ('* *) = [*])]] 
proves
  imp p p
= [*]
</pre>

Amazingly, it also works with infix notation :

<pre>
! MP ^p ^q ((p imp q) (p q) = [*])
! AK ^p ^q (p imp (q imp p) = [*])
! AS ^p ^q ^r ((p imp (q imp r)) imp ((p imp q) imp (p imp r)) = [*])
! EFQ ^p (false imp p = [*])
! RAA ^p (((p imp false) imp false) imp p = [*])
! GEN ^p (p (all ^x p) = [*])
! PART ^p ^t ((all p) imp (p t) = [*])
! PERMUT ^p ^q ((all ^x  :  p imp (q x)) imp (p imp (all q)) = [*])
! SOME ^p (((all p) imp false) imp
                   ((p (some ^x ((p x) imp false))) imp false)
               = [*])

! lemma1 (AS p (p imp p) p)

! lemma2 (AK p (p imp p))

! lemma3 (MP (p imp ((p imp p) imp p))
               ((p imp (p imp p)) imp (p imp p)))

! lemma4 (lemma1 ( (p imp ((p imp p) imp p))
                      ((p imp (p imp p)) imp (p imp p)) ) )

! lemma5 { lemma4 , lemma3 }

! lemma6 (lemma2
              ((p imp (p imp p)) imp
               (p imp p)))

! lemma7 { lemma6 , lemma5 }

! lemma8 (AK p p)

! lemma9
 (MP
    (p imp (p imp p))
    (p imp p))

! lemma10 (lemma7 ((p imp (p imp p)) (p imp p)))

! lemma11 { lemma10 , lemma9 }

! lemma12 (lemma8 (p imp p))

! theorem1 { p imp p , { lemma12 , lemma11 } }

theorem1
</pre>

It proves the same sentence with the infix notation "p > p" :

<pre>
PL> run "propi.prf"

The proof
  @[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[@[*] { p imp p ,
                                                   { * ,
                                                     '* } }] ('''* (p imp p))] { * ,
                                                                                 '* }] (''* (p imp (p imp p) (p imp p)))] (''''''''''''''''* (p imp (p imp p)) (p imp p))] (''''''''''''''* p p)] { * ,
                                                                                                                                                                                                    '* }] ('''* (p imp (p imp p) imp (p imp p)))] { * ,
                                                                                                                                                                                                                                                    '* }] (''* (p imp (p imp p imp p) (p imp (p imp p) imp (p imp p))))] (''''''''''* (p imp (p imp p imp p)) (p imp (p imp p) imp (p imp p)))] (''''''''* p (p imp p))] (''''''* p (p imp p) p)] [(all * imp false imp (* (some ['* * imp false]) imp false) = [*])]] [[(all [:] '* imp (* x) imp ('* imp (all *)) = [*])]]] [[(all '* imp ('* *) = [*])]]] [(* (all ['*]) = [*])]] [(* imp false imp false imp * = [*])]] [(false imp * = [*])]] [[[(''* imp ('* imp *) imp (''* imp '* imp (''* imp *)) = [*])]]]] [[('* imp (* imp '*) = [*])]]] [[('* imp * ('* *) = [*])]]
proves
  p imp p
= [*]
</pre>

Historically, Proof Logic comes from <a href="http://log.chez.com/text/logic/sslc.txt">SSLC (Simplified Symbolic Lambda Calculus)</a>, with a new notation introduced, the "AXM" proof replaced by "a = b", and DB0, DBS and DBL respectively replaced by VAR, NXV and FNC in Haskell representation.
SSLC itself comes from Schönfinkel and Curry's Combinatory Logic and Church's Lambda Calculus throught <a href="http://log.chez.com/text/logic/slc-hist.html">this history</a>.

<p>

<a href="http://log.chez.com/src/slc/pl.c">Here</a> is a C implementation of Proof Logic.

</body>
</html>
