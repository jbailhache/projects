\documentclass[10pt]{article}
\title{Transfinite ordinals}
\usepackage[left=1cm,right=1cm,top=2cm,bottom=2cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\begin{document}

\setlength{\parindent}{0pt}

\vspace{-0.4cm}

\begin{center}
\textbf{TRANSFINITE ORDINALS}

by Jacques Bailhache, January-february 2018
\end{center}

\section{Defining transfinite ordinal numbers}

Natural numbers can be represented by sets. Each number is represented by the set of all numbers smaller than it.
\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}
\item \( 0 = \lbrace\rbrace \) (the empty set)
\item \( 1 = \lbrace 0 \rbrace = \lbrace\lbrace\rbrace\rbrace \)
\item \( 2 = \lbrace 0, 1 \rbrace = \lbrace\lbrace\rbrace,\lbrace\lbrace\rbrace\rbrace\rbrace \)
\item \( 3 = \lbrace 0, 1, 2 \rbrace = \lbrace\lbrace\rbrace,\lbrace\lbrace\rbrace\rbrace,\lbrace\lbrace\rbrace,\lbrace\lbrace\rbrace\rbrace\rbrace\rbrace \)
\item ...
\end{itemize}
The successor of a natural number can be defined by \( suc(n) = n+1 = n \cup \lbrace n \rbrace \).

We have \( n \leq p \) if and only if \( n \subseteq p \).

\( \mathbb{N} \) is the set of all natural numbers : \( \mathbb{N} = \lbrace0,1,2,3,\ldots\rbrace \)
The natural numbers can be generalized to what is called "transfinite ordinal numbers", or simply "ordinal numbers" or "ordinals", by considering that infinite sets represent ordinal numbers. \( \mathbb{N} \) considered as an ordinal number is written \( \omega \).
\( \omega \) is the least ordinal which is greater than all the numbers 0, 1, 2, 3, ... We say that \( \omega \) is a limit ordinal and 0, 1, 2, 3, ... is a fundamental sequence of \( \omega \). This is written : \( \omega = sup \lbrace 0, 1, 2, 3, ... \rbrace \) or \( \omega = lim ( n \mapsto n )  \) because the n-th element (starting with 0) of the sequence is n. An ordinal does not have a unique fundamental sequence, for example 1, 2, 3, 4, ... is also a fundamental sequence of \( \omega \), because the least ordinal that is greater than all ordinals of this sequence is also \( \omega \) (more generally the limit ordinal is the same if any number of the least items of a sequence are removed), and the same stands for the sequence 0, 2, 4, 6, ...

Any ordinal can be defined as the least ordinal strictly greater than all ordinals of a set : the empty set for 0, \(\lbrace \alpha \rbrace\) for the successor of \( \alpha \),  \(\lbrace \alpha_0,\alpha_1,\alpha_2,...\rbrace\) for an ordinal with fundamental sequence \(\alpha_0, \alpha_1, \alpha_2, ...\)

The successor can be generalized to transfinite ordinal numbers : \( suc(\omega) = \omega+1 =\omega \cup \lbrace \omega \rbrace = \lbrace 0, 1, 2, 3, \ldots, \omega \rbrace ; suc(suc(\omega)) = \omega+2 = \lbrace 0, 1, 2, 3, \ldots, \omega, \omega+1 \rbrace \) and so on.

Then we can consider the set \( \lbrace 0, 1, 2, 3, \ldots, \omega, \omega+1, \omega+2, \omega+3, \ldots \rbrace \) which is a limit ordinal, and \( \omega, \omega+1, \omega+2, \omega+3, \ldots \) is a fundamental sequence of this ordinal. This ordinal is \( \omega+\omega = \omega \cdot 2 \) or \( \omega \times 2 \) or \( \omega 2 \).

Then we can go on building greater and greater ordinals : \( \omega \cdot 3, \ldots, \omega \cdot \omega = \omega^2, \omega^3, \ldots, \omega^\omega, \omega^{\omega^\omega}, \ldots \).

\bigskip

The definitions of arithmetical operations can be generalized to ordinals :

\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}
\item addition : \( \alpha+0=\alpha ; \alpha+suc(\beta)=suc(\alpha+\beta); \alpha+lim(f)=lim(n \mapsto \alpha+f(n)) \)

\item multiplication : \( \alpha \cdot 0 = 0 ; \alpha \cdot suc(\beta) = (\alpha \cdot \beta) + \alpha ; \alpha \cdot lim(f) = lim (n \mapsto \alpha \cdot f(n)) \)

\item exponentiation : \( \alpha^0 = 1 ; \alpha^{suc(\beta)} = \alpha^\beta \cdot \alpha ; \alpha^{lim(f)} = lim (n \mapsto \alpha^{f(n)}) \)
\end{itemize}

Note that addition and multiplication are not commutative, for example \( 1+\omega = \omega \neq \omega+1 \), because if we take 0, 1, 2, 3, ... as fundamental sequence of \( \omega \), then a fundamental sequence of \( 1+\omega \) is 1+0, 1+1, 1+2, 1+3, ... = 1, 2, 3, 4, ... and the least ordinal which is greater than all ordinals of this sequence is \( \omega \). We will say that "1+" is "absorbed" by \( \omega \). More generally, we have \( 1+\alpha = \alpha \) for any ordinal \( \alpha \geq \omega \).

\section{Veblen functions}

The next step is the limit or least upper bound of \( \omega, \omega^\omega, \omega^{\omega^\omega}, \ldots \) which is called \( \varepsilon_0 \). Note that we have \( \omega^{\varepsilon_0} = \varepsilon_0 \). We say that \( \varepsilon_0 \) is a fixed point (the least one) of the function \( \alpha \mapsto \omega^\alpha \).

Then we can go on with \( \varepsilon_0+1, \varepsilon_0+2, \ldots, \varepsilon_0+\varepsilon_0 = \varepsilon_0 \cdot 2, \ldots, \varepsilon_0 \cdot \varepsilon_0 = {\varepsilon_0}^2, \varepsilon_0^{\varepsilon_0}, ...\)

The limit of \( \varepsilon_0, \varepsilon_0^{\varepsilon_0}, \varepsilon_0^{\varepsilon_0^{\varepsilon_0}}, \ldots \) is called \( \varepsilon_1 \). It can be shown that it is also the limit of \( \varepsilon_0+1, \omega^{\varepsilon_0+1}, \omega^{\omega^{\varepsilon_0+1}}, \ldots \) (see proof below).

These two fundamental sequences are examples of two ways of ascending ordinals :
\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}
\item Build greater ordinals from known ones by increasing them using operations like successor, addition, multiplication, exponentiation, ... This method is used by the RSH0 notation which we will study later.

\item When we have found a function that, when applied to a given ordinal, gives a greater one (for example \( \alpha \mapsto \omega^\alpha \)), enumerate the fixed points of this function. A fixed point of a function f is a value (for example an ordinal) \( \alpha \) with \( f(\alpha) = \alpha \). Under some conditions (see below), the least fixed point of f is the limit of 0, f(0), f(f(0)), f(f(f(0))), ... If it is called \( \alpha \), the next fixed point is the limit of \( \alpha+1, f(\alpha+1), f(f(\alpha+1)), f(f(f(\alpha+1))), \ldots \).
More generally, the least fixed point of f that is greater or equal to \( \zeta \) is the limit of \( \zeta, f(\zeta), f(f(\zeta)), \ldots\).
The Veblen functions use this method.

\end{itemize}

The required conditions are described for example in http://www.cs.man.ac.uk/~hsimmons/ORDINAL-NOTATIONS/Fruitful.pdf page 8 lemma 3.9 : 

For each fruitful function f and each ordinal \( \zeta, f^\omega(\zeta+1) \) is the least ordinal \( \nu \) such that \( \zeta < \nu = f(\nu) \), or the least fixed point of f that is strictly greater than \( \zeta \) (or greater than or equal to \( \zeta+1 \)). 

\( f^\omega(\zeta+1) \) is the limit of \( \zeta+1, f(\zeta+1), f(f(\zeta+1)), \ldots \). 

A fruitful function is a function that is inflationary, monotone, big, and continuous.

A function f is inflationary if \( \alpha \leq f(\alpha) \), monotone if \( \alpha \leq \beta \Rightarrow f(\alpha) \leq f(\beta) \), big if \( \omega^\alpha \leq f(\alpha) \) except possibly for \( \alpha = 0 \), continuous if f(VA) = Vf[A] where VA is the pointwise supremum of the set A.

\bigskip

We will now prove by induction the equivalence of the two fundamental sequences above.

We will use the notation \( \alpha^{\vdots^{\alpha^\beta}} \) for an an "exponential tower" with \( \alpha \) repeated n times. 


Note that the ordinals respectively limits of the fondamental sequence whose n-th term is \(\varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}} \) and the one whose n-th term is \( \varepsilon_0^{\varepsilon_0^{\vdots^{\varepsilon_0^{\varepsilon_0}}}} \) is the same, the least fixed point of the function \( \alpha \mapsto {\varepsilon_0}^\alpha \), which is greater than \( \omega \) and also than \( \varepsilon_0 \).

So we have proved what we want if we prove that, for any n, we have \( \omega^{\omega^{\vdots^{\omega^{\omega^{\varepsilon_0+1}}}}} = \varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}} \). 

For n = 0, we have \( \omega^{\omega^{\varepsilon_0+1}} = \omega^{\omega^{\varepsilon_0}\cdot\omega} = \omega^{\varepsilon_0\cdot\omega} = (\omega^{\varepsilon_0})^\omega = {\varepsilon_0}^\omega \). 

Now suppose we have \( \omega^{\omega^{\vdots^{\omega^{\omega^{\varepsilon_0+1}}}}} = \varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}} \). 

We must prove the equality for n+1, which can be written \( \omega^{\omega^{\omega^{\vdots^{\omega^{\omega^{\varepsilon_0+1}}}}}} = \varepsilon_0^{\varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}}} \). 

We have \( \omega^{\omega^{\omega^{\vdots^{\omega^{\omega^{\varepsilon_0+1}}}}}} = \omega^{\varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}}} \) (by our hypothesis) \( = \omega^{\varepsilon_0^{1+\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}}} \) (for the same reason than \( 1+\omega = \omega \), see above) \( = \omega^{\varepsilon_0\cdot\varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}}} = (\omega^{\varepsilon_0})^{\varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}}} = \varepsilon_0^{\varepsilon_0^{\varepsilon_0^{\vdots^{{\varepsilon_0}^\omega}}}} \). QED.


In a similar way, the limit of \( \varepsilon_1, \varepsilon_1^{\varepsilon_1}, \varepsilon_1^{\varepsilon_1^{\varepsilon_1}}, \ldots \) is called \( \varepsilon_2 \) and is also the limit of \( \varepsilon_1+1, \omega^{\varepsilon_1+1}, \omega^{\omega^{\varepsilon_1+1}}, \ldots \).

We can define the same way \( \varepsilon_n \) for any natural number n. Then \( \varepsilon_\omega \) is defined as the limit of \( \varepsilon_0, \varepsilon_1, \varepsilon_2, \varepsilon_3, \ldots \), and \( \varepsilon_{\omega+1} \) as the limit of \( \varepsilon_\omega, \varepsilon_\omega^{\varepsilon_\omega}, \varepsilon_\omega^{\varepsilon_\omega^{\varepsilon_\omega}}, \ldots \) or \( \varepsilon_\omega+1, \omega^{\varepsilon^\omega+1}, \omega^{\omega^{\varepsilon_\omega+1}}, \ldots \).

After comes \( \varepsilon_{\varepsilon_0} \), and the limit of \( \varepsilon_0, \varepsilon_{\varepsilon_0}, \varepsilon_{\varepsilon_{\varepsilon_0}}, \ldots \) which is called \( \zeta_0 \). 
This is the least fixed point of \( \alpha \mapsto \varepsilon_\alpha \). The next one is \( \zeta_1 \) which is the limit of \( \zeta_0+1, \varepsilon_{\zeta_0+1}, \varepsilon_{\varepsilon_{\zeta_0+1}}, \ldots \). 
Then we get \( \zeta_2, \zeta_3, \ldots, \zeta_\omega, \zeta_{\omega+1}, \ldots, \zeta_{\varepsilon_0}, \ldots, \zeta_{\zeta_0}, \ldots, \zeta_{\zeta_{\zeta_0}}, \ldots \).
The limit of \( 0, \zeta_0, \zeta_{\zeta_0}, \zeta_{\zeta_{\zeta_0}}, \ldots \) is called \( \eta_0 \). 

We could go on using successively different greek letters, or define a function \( \varphi \) with two variables by : 

\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}

\item \( \varphi(0,\alpha) = \omega^\alpha \)

\item \( \varphi(1,\alpha) = \varepsilon_\alpha \)

\item \( \varphi(2,\alpha) = \zeta_\alpha \)

\item \( \varphi(3,\alpha) = \eta_\alpha \)

\item \( \varphi(\alpha+1,\beta) \) is the \( (1+\beta) \)-th fixed point of \( \xi \mapsto \varphi(\alpha,\xi) \) .

\end{itemize}

Then we can enumerate the fixed points of the function \( \alpha \mapsto \varphi(\alpha,0) \) and define \( \Gamma_\alpha \) as the \( (1+\alpha) \)-th fixed point of this function, or add another variable to the \( \varphi \) function 
and define \( \varphi(1,0,\alpha) \) as the \( (1+\alpha) \)-th fixed point of this function. So we have \( \Gamma_\alpha = \varphi(1,0,\alpha) \).

More generally, we can define \( \varphi(\alpha_n, \alpha_{n-1}, \ldots, \alpha_1, \alpha_0) \). 

It is sometimes written \( \varphi_{\alpha_n,\alpha_{n-1},\ldots,\alpha_1}(\alpha_0) \) since \( \alpha_0 \) plays a different role than the other variables.

See for example https://en.wikipedia.org/wiki/Veblen\_function :

"Let \(z\) be an empty string or a string consisting of one or more comma-separated zeros \(0,0,...,0\) and \(s\) be an empty string or a string consisting of one or more comma-separated ordinals \(\alpha _{1},\alpha _{2},...,\alpha _{n}\) with \(\alpha _{1}>0\). The binary function \(\varphi (\beta ,\gamma )\) can be written as \(\varphi (s,\beta ,z,\gamma )\) where both \(s\) and \(z\) are empty strings.

The finitary Veblen functions are defined as follows:

\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}

\item \(\varphi (\gamma )=\omega ^{\gamma }\)
\item \(\varphi (z,s,\gamma )=\varphi (s,\gamma )\)
\item if \(\beta >0\), then \(\varphi (s,\beta ,z,\gamma )\) denotes the \((1+\gamma )\)-th common fixed point of the functions \(\xi \mapsto \varphi (s,\delta ,\xi ,z)\) for each \(\delta <\beta\)

\end{itemize}

(...)

The limit of the \(\varphi(1,0,...,0)\) where the number of zeroes ranges over \( \omega \), is sometimes known as the "small" Veblen ordinal.

Every non-zero ordinal \(\alpha\) less than the small Veblen ordinal (SVO) can be uniquely written in normal form for the finitary Veblen function:

\(\alpha =\varphi (s_{1})+\varphi (s_{2})+\cdots +\varphi (s_{k})\)

where

\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}

\item \(k\) is a positive integer
\item \(\varphi (s_{1})\geq \varphi (s_{2})\geq \cdots \geq \varphi (s_{k})\)
\item \(s_{m}\) is a string consisting of one or more comma-separated ordinals \(\alpha _{m,1},\alpha _{m,2},...,\alpha _{m,n_{m}}\) where \(\alpha _{m,1}>0\) and each \(\alpha _{m,i}<\varphi (s_{m})\)

\end{itemize} 

For limit ordinals \(\alpha<SVO\), written in normal form for the finitary Veblen function:

\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}

\item \((\varphi(s_1)+\varphi(s_2)+\cdots+\varphi(s_k))[n]=\varphi(s_1)+\varphi(s_2)+\cdots+\varphi(s_k)[n]\),
\item \(\varphi(\gamma)[n]=\)
\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}
\item n if \( \gamma=1 \)
\item \(\varphi(\gamma-1)\cdot n \) if \( \gamma \) is a successor ordinal
\item \( \varphi(\gamma[n]) \) if \( \gamma \) is a limit ordinal
\end{itemize}
\item \(\varphi(s,\beta,z,\gamma)[0]=0\) and \(\varphi(s,\beta,z,\gamma)[n+1]=\varphi(s,\beta-1,\varphi(s,\beta,z,\gamma)[n],z)\) if \(\gamma=0\) and \(\beta\) is a successor ordinal,
\item \(\varphi(s,\beta,z,\gamma)[0]=\varphi(s,\beta,z,\gamma-1)+1\) and \(\varphi(s,\beta,z,\gamma)[n+1]=\varphi(s,\beta-1,\varphi(s,\beta,z,\gamma)[n],z)\) if \(\gamma\) and \(\beta\) are successor ordinals,
\item \(\varphi(s,\beta,z,\gamma)[n]=\varphi(s,\beta,z,\gamma[n])\) if \(\gamma\) is a limit ordinal,
\item \(\varphi(s,\beta,z,\gamma)[n]=\varphi(s,\beta[n],z,\gamma)\) if \(\gamma=0\) and \(\beta\) is a limit ordinal,
\item \(\varphi(s,\beta,z,\gamma)[n]=\varphi(s,\beta[n],\varphi(s,\beta,z,\gamma-1)+1,z)\) if \(\gamma\) is a successor ordinal and \(\beta\) is a limit ordinal. "

\end{itemize}

The Veblen function can be generalized to transfinitely many variables with a finite number different from 0. Instead of writing the list of all the variable of the Veblen function, we can write only the non zero variables with position as indice, for example \( \varphi(\alpha,0,\beta,\gamma) = \varphi(\alpha_3,\beta_1,\gamma_0) \). We can then generalize the Veblen function by allowing any ordinal as indices, writing for example \( SVO = \varphi(1_\omega) \). The limit of the ordinals that can be written with this notation is called the large Veblen ordinal (LVO).

\bigskip

According to Wikipedia, "The definition can be given as follows: let \(\alpha\) be a transfinite sequence of ordinals (i.e., an ordinal function with finite support) which ends in zero (i.e., such that \(\alpha_0\)=0), and let \(\alpha[0\mapsto\gamma]\) denote the same function where the final 0 has been replaced by \(\gamma\). Then \(\gamma\mapsto\varphi(\alpha[0\mapsto\gamma])\) is defined as the function enumerating the common fixed points of all functions \( \xi \mapsto \varphi(\beta) \) where \( \beta \) ranges over all sequences which are obtained by decreasing the smallest-indexed nonzero value of \( \alpha \) and replacing some smaller-indexed value with the indeterminate \( \xi \) (i.e., \( \beta = \alpha [\iota_0 \mapsto \zeta, \iota \mapsto \xi ] \) meaning that for the smallest index \( \iota_0 \)  such that \( \alpha_{\iota_0} \)  is nonzero the latter has been replaced by some value \( \zeta < \alpha_{\iota_0} \)  and that for some smaller index \( \iota < \iota_0 \) , the value \( \alpha_\iota = 0 \) has been replaced with \( \xi \) )."

\bigskip

Schütte brackets or Klammersymbols are another way to write Veblen fuctions with transfinitely many variables. A Schütte bracket consists in a matrix with two lines, with the positions of the variables in the second line in increasing order, and the corresponding values in the first line. This matrix is preceded by the function  \( \xi  \mapsto \varphi(\xi) \). If we take \( \xi \mapsto \omega^\xi \), we get the equivalent of the Veblen function. With this notation, the previous example is written : 

\[
( \xi \mapsto \omega^\xi ) 
  \begin{pmatrix}
    \gamma & \beta & \alpha \\
    0 & 1 & 3
  \end{pmatrix}
\]

In some of his papers, Harold Simmons puts the function after the matrix, which is more logical, the matrix being considered as a function which, when applied to a function, gives an ordinal :

\[
  \begin{pmatrix}
    \gamma & \beta & \alpha \\
    0 & 1 & 3
  \end{pmatrix}
( \xi \mapsto \omega^\xi ) 
\]


When the function at the left of the matrix is \( \xi \mapsto \omega^\xi \), it is sometimes omitted. Example :

\[
  \begin{pmatrix}
    \gamma & \beta & \alpha \\
    0 & 1 & 3
  \end{pmatrix}
\]

The corresponding fundamental sequences can be found in https://sites.google.com/site/travelingtotheinfinity/fundamental-sequences-for-extended-veblen-function .

Here is an Agda implementation of this notation :

\begin{verbatim}

{- 
   A definition of the large Veblen ordinal in Agda
   by Jacques Bailhache, March 2016

   See https://en.wikipedia.org/wiki/Veblen_function

    (1) phi(a)=w**a for a single variable,

    (2) phi(0,an-1,...,a0)=phi(an-1,...,a0), and

    (3) for a>0, c->phi(an,...,ai+1,a,0,...,0,c) is the function enumerating the common fixed points of the
        functions x->phi(an,...,ai+1,b,x,0,...,0) for all b<a.

    (4) Let a be a transfinite sequence of ordinals (i.e., an ordinal function with finite support) which ends in 
        zero  (i.e., such that a0=0), and let a[0->c] denote the same function where the final 0 has been replaced 
        by c. 
        Then c->phi(a[0->c]) is defined as the function enumerating the common fixed points of all functions 
        x->phi(b) where b ranges over all sequences which are obtained by decreasing the smallest-indexed nonzero 
        value of a  and replacing some smaller-indexed value with the indeterminate x (i.e., b=a[i0->z,i->x] 
        meaning that for the smallest index i0 such that ai0 is nonzero the latter has been replaced by some value 
        z<ai0 and that for some smaller index i<i0, the value ai=0 has been replaced with x).

-}


module LargeVeblen where

 data Nat : Set where
  O : Nat
  1+ : Nat -> Nat

 data Ord : Set where
  Zero : Ord
  Suc : Ord -> Ord
  Lim : (Nat -> Ord) -> Ord

 -- rpt n f x = f^n(x)
 rpt : {t : Set} -> Nat -> (t -> t) -> t -> t
 rpt O f x = x
 rpt (1+ n) f x = rpt n f (f x)

 -- smallest fixed point of f greater than x, limit of x, f x, f (f x), ...
 fix : (Ord -> Ord) -> Ord -> Ord
 fix f x = Lim (\n -> rpt n f x)

 w = fix Suc Zero -- not a fixed point in this case !

 -- cantor a b = b + w^a
 cantor : Ord -> Ord -> Ord
 cantor Zero a = Suc a
 cantor (Suc b) a = fix (cantor b) a
 cantor (Lim f) a = Lim (\n -> cantor (f n) a)

 -- phi0 a = w^a
 phi0 : Ord -> Ord
 phi0 a = cantor a Zero

 -- Another possibility is to use phi'0 instead of phi0 in the definition of phi,
 -- this gives a phi function which grows slower
 phi'0 : Ord -> Ord
 phi'0 Zero = Suc Zero
 phi'0 (Suc a) = Suc (phi'0 a)
 phi'0 (Lim f) = Lim (\n -> phi'0 (f n))

 -- Associative list of ordinals
 infixr 40 _=>_&_
 data OrdAList : Set where
  Zeros : OrdAList
  _=>_&_ : Ord -> Ord -> OrdAList -> OrdAList

 -- Usage : phi al, where al is the associative list of couples index => value ordered by increasing values,
 -- absent indexes corresponding to Zero values

 phi : OrdAList -> Ord 
 phi              Zeros  = phi0 Zero -- (1) phi(0) = w**0 = 1 
 phi (Zero => a & Zeros) = phi0 a    -- (1) phi(a) = w**a
 phi (            k => Zero & al) = phi al -- eliminate unnecessary Zero value
 phi (Zero => a & k => Zero & al) = phi (Zero => a & al) -- idem
 phi (Zero => a & Zero => b & al) = phi (Zero => a & al) -- should not appear but necessary for completeness
 phi (Zero => Lim f & al) = Lim (\n -> phi (Zero => f n & al)) -- canonical treatment of limit
 phi (                Suc k => Suc b & al) = fix (\x -> phi (k => x & Suc k => b & al)) Zero 
  -- (3) least fixed point
 phi (Zero => Suc a & Suc k => Suc b & al) = fix (\x -> phi (k => x & Suc k => b & al)) (Suc (phi (Zero => a & 
Suc k => Suc b & al))) -- (3) following fixed points
 phi (                Suc k => Lim f & al) = Lim (\n -> phi (Suc k => f n & al)) -- idem 
 phi (Zero => Suc a & Suc k => Lim f & al) = Lim (\n -> phi (k => Suc (phi (Zero => a & Suc k => Lim f & al)) & 
Suc k => f n & al)) -- idem  
 phi (                Lim f => Suc b & al) = Lim (\n -> phi (f n => (Suc Zero) & Lim f => b & al)) 
 phi (Zero => Suc a & Lim f => Suc b & al) = Lim (\n -> phi (f n => phi (Zero => a & Lim f => Suc b & al) & Lim 
f => b & al))
 phi (                Lim f => Lim g & al) = Lim (\n -> phi (Lim f => g n & al))
 phi (Zero => Suc a & Lim f => Lim g & al) = Lim (\n -> phi (f n => phi (Zero => a & Lim f => Lim g & al) & Lim 
f => g n & al)) 

 SmallVeblen = phi (w => Suc Zero & Zeros)

 LargeVeblen = fix (\x -> phi (x => Suc Zero & Zeros)) (Suc Zero)

{-
Normally it should terminate because the parameter of phi lexicographically decreases, but Agda is not clever enough to see it, 
so it must be called with no termination check option :

$ agda -I --no-termination-check LargeVeblen.agda
                 _ 
   ____         | |
  / __ \        | |
 | |__| |___  __| | ___
 |  __  / _ \/ _  |/ __\     Agda Interactive
 | |  |/ /_\ \/_| / /_| \
 |_|  |\___  /____\_____/    Type :? for help.
        __/ /
        \__/

The interactive mode is no longer supported. Don't complain if it doesn't work.
Checking LargeVeblen (/perso/ord/LargeVeblen.agda).
Finished LargeVeblen.
Main> phi Zeros
Suc Zero

\end{verbatim}

\section{Extending Veblen function with transfinitely many variables}


We start with the large Veblen ordinal which is the least fixed point of the function \( \alpha \mapsto \varphi(1_\alpha) \). Then we consider a function F which enumerates the fixed points of \( \alpha \mapsto \varphi(1_\alpha) \). So we have LVO = F(0). The next fixed point F(1) is the limit of \( LVO+1, \varphi(1_{LVO+1}), \varphi(1_{\varphi(1_{LVO+1})}), ... \)

Then we can consider the fixed points of the function F and define a function G which enumerates these fixed points, then a function H which enumerates the fixed points of G, and so on.

This construction is similar to \( \varepsilon \) which enumerates the fixed points of \( \alpha \mapsto \omega^\alpha \), \( \zeta \) which enumerates the fixed points of \( \varepsilon \), \( \eta \) which enumerates the fixed points of \( \zeta \).

Like we have defined :

 - \( \varphi_0(\alpha) = \omega^\alpha \)

 - \( \varphi_1(\alpha) = \varepsilon(\alpha) \)

 - \( \varphi_2(\alpha) = \zeta(\alpha) \)

...

we can define :

 - \( \varphi^+_0(\alpha) = F(\alpha) \)

 - \( \varphi^+_1(\alpha) = G(\alpha) \)

 - \( \varphi^+_2[\alpha) = H(\alpha) \)

 ...

With this notation we can write \( LVO = \varphi^+_0(0) \).

Then \( \varphi^+_\alpha(\beta) \) can be written as a binary function \( \varphi^+(\alpha,\beta) \) which can be generalized to finitely many variables like \( \varphi^+(\alpha,\beta,\gamma) \) and transfinitely many variables like \( \varphi^+(1_\omega) \).

Then we can consider the fixed points of the function \( \alpha \mapsto \varphi^+(1_\alpha) \) and define a function \( \varphi^{++}_0 \) which enumerates these fixed points.

The same way we can define \( \varphi^{+++} \), \( \varphi^{++++} \), ...

We can then define a new notation : 

 - \( \Phi_0 = \varphi \)
 
 - \( \Phi_1 = \varphi^+ \)

 - \( \Phi_2 = \varphi^{++} \)

 ...

\bigskip

There is another way to express this construction.

There are different conventions for \( \varphi_0(x) \), like \( \omega^x \) or \( \varepsilon_x \). We can write explicitely the convention chosen for \( \varphi_0 \) by writing "\( \varphi_f(\alpha,\beta) \)" for "\( \varphi_\alpha(\beta) \) with function f used for \( \varphi_0 \)".  With this notation we have:

 - \( \varphi_f(0,\beta) = f(\beta) \)
 
 - \( \varphi_f(\alpha+1,\beta) = (1+\beta) \)th fixed point of the function \( \beta \mapsto \varphi_f(\alpha,\beta) \)
 
 - \( \varphi_f(\lambda,\beta) = (1+\beta) \)th common fixed point of the function \( \beta \mapsto \varphi_f(\alpha,\beta) \) for all \( \alpha < \lambda \), if \( \lambda \) is a limit ordinal.

( See http://www.cs.man.ac.uk/~hsimmons/TEMP/OrdNotes.pdf )

Then we generalize the binary function \( \varphi_f(\alpha,\beta) \) to finitely many variables: for example \( \varphi_f(1,0,\alpha) = (1+\alpha) \)th common fixed point of the function \( \xi \mapsto \varphi(\xi,0) \) ( see https://en.wikipedia.org/wiki/Veblen\_function ) and to infinitely many variables with a finite number of them different from 0, for example \( \varphi_f(1_\omega) \).

Then we can define new \( \varphi \) functions by taking for \( \varphi_0 \) the function \( \xi \mapsto \varphi_f(1_\xi) \) and define functions \( \varphi_{\xi \mapsto \varphi_f(1_\xi)} \) with 2 variables, with finitely many variables and with transfinitely many variables.

To make a correspondence with my previous construction, if f is the function \( \xi \mapsto \omega^\xi \), then \( \varphi_f(\alpha,\beta) \) corresponds to what I wrote \( \varphi_\alpha(\beta) \), and \( \varphi_{\xi \mapsto \varphi_f(1_\xi)}(\alpha,\beta) \) to \( \varphi^+_\alpha(\beta) \). 

If we define the function S by \( S(f)(\xi) = \varphi_f(1_\xi) \), then \( \varphi_{\xi \mapsto \varphi_f(1_\xi)}\) can be written \( \varphi_{S(f)} \). We can then consider \( \varphi_{S(S(f))} \) and so on.

Given an ordinal \( \alpha \), we can iterate transfinitely "\( \alpha \) times" the application of S to an initial function \( f_0 \), for example \( f_0(\xi) = \omega^\xi \), to obtain a function which I will write \( S^\alpha(f_0) \). We can use this function to define a function \( \varphi_{S^\alpha(f_0)} \) which permits to construct big ordinals.




\section{Simmons notation}

Harold Simmons defined a notation ( see http://www.cs.man.ac.uk/~hsimmons/ORDINAL-NOTATIONS/ordinal-notations.html ) based on fixed points enumeration which "contains" Veblen functions and permits to go further. 

He uses the lambda calculus formalism, in which f x represents the application of function f to x, and f x y = (f x) y the application of function f to x which gives another function which is applied to y giving the final result. 
He uses tho notation \( x \mapsto y \) to represent the function which, when applied to x, gives y (instead of the traditional lambda calculus notation \( \lambda x . y \) ).

\bigskip

\( Fix\ f \zeta = f^\omega (\zeta+1) \) = limit of \( \zeta+1, f (\zeta+1), f (f (\zeta+1)), \ldots \) is the least fixed point of the function f which is strictly greater than \( \zeta \), which means the least ordinal \( \nu \) satisfying \( f\ \nu = \nu \) and \( \nu > \zeta \).

\( Next = Fix (\alpha \mapsto \omega^\alpha) \) ; \( Next\ \zeta \) is the next \( \varepsilon_\alpha \) after \( \zeta \).

\( [0] h = Fix (\alpha \mapsto h^\alpha 0) \)

\( [1] h g = Fix (\alpha \mapsto h^\alpha g 0) \)

\( [2] h g f = Fix (\alpha \mapsto h^\alpha g f 0) \) 

... and so on ...


\subsection{Implementation}

Here is an implementation of the Simmons hierarchy in Haskell :

\begin{verbatim}

module Simmons where

 -- Natural numbers
 data Nat 
  = ZeroN
  | SucN Nat

 -- Ordinals
 data Ord 
  = Zero
  | Suc Ord
  | Lim (Nat -> Ord)

 -- Ordinal corresponding to a given natural
 ordOfNat ZeroN = Zero
 ordOfNat (SucN n) = Suc (ordOfNat n)

 -- omega
 w = Lim ordOfNat

 lim0 s = Lim s
 lim1 f x = lim0 (\n -> f n x)
 lim2 f x = lim1 (\n -> f n x)

 -- this does not work :
 -- lim ZeroN s = Lim s
 -- lim (SucN p) f = \x -> lim p (\n -> f n x)

 -- f^a(x)
 fpower0 f Zero x = x
 fpower0 f (Suc a) x = f (fpower0 f a x)
 fpower0 f (Lim s) x = Lim (\n -> fpower0 f (s n) x)

 fpower l f Zero x = x
 fpower l f (Suc a) x = f (fpower l f a x)
 fpower l f (Lim s) x = l (\n -> fpower l f (s n) x)

 -- fix f z = least fixed point of f which is > z
 fix f z = fpower lim0 f w (Suc z) -- Lim (\n -> fpower0 f (ordOfNat n) (Suc z))

 -- cantor b a = a + w^b
 cantor Zero a = Suc a
 cantor (Suc b) a = fix (cantor b) a
 cantor (Lim s) a = Lim (\n -> cantor (s n) a)
 
 -- expw a = w^a
 expw a = cantor a Zero

 -- next a = least epsilon_b > a
 next = fix expw

 -- [0]
 simmons0 h = fix (\a -> fpower lim0 h a Zero)

 -- [1]
 simmons1 h1 h0 = fix (\a -> fpower lim1 h1 a h0 Zero)

 -- [2]
 simmons2 h2 h1 h0 = fix (\a -> fpower lim2 h2 a h1 h0 Zero)

 -- Large Veblen ordinal 
  lvo = simmons2 simmons1 simmons0 next w



$ hugs
__   __ __  __  ____   ___      _________________________________________
||   || ||  || ||  || ||__      Hugs 98: Based on the Haskell 98 standard
||___|| ||__|| ||__||  __||     Copyright (c) 1994-2005
||---||         ___||           World Wide Web: http://haskell.org/hugs
||   ||                         Bugs: http://hackage.haskell.org/trac/hugs
||   || Version: September 2006 _________________________________________

Haskell 98 mode: Restart with command line option -98 to enable extensions

Type :? for help
Hugs> :load simmons
Simmons> lvo
ERROR - Cannot find "show" function for:
*** Expression : lvo
*** Of type    : Ord

Simmons>



\end{verbatim}

\subsection{Correspondence with Veblen functions}

\( \varepsilon_0 \) is the next \( \varepsilon_\alpha \) after 0 (or after \( \omega \), or after any ordinal less than \( \varepsilon_0 \), so we have \( \varepsilon_0 = Next\ 0 = Next\ \omega \).

\( \varepsilon_1 \) is the next \( \varepsilon_\alpha \) after \( \varepsilon_0 \), so we have \( \varepsilon_1 = Next\ \varepsilon_0 = Next\ (Next\ 0) = Next^2 0 = Next\ (Next\ \omega) = Next^2 \omega \).

\( \varepsilon_2 \) is the next \( \varepsilon_\alpha \) after \( \varepsilon_1 \), so we have \( \varepsilon_2 = Next\ \varepsilon_1 = Next\ (Next\ (Next\ 0)) = Next^3 0 = Next\ (Next\ (Next\ \omega)) = Next^3 \omega \).

...

\( \varepsilon_\omega \) is the limit of \( \varepsilon_0, \varepsilon_1, \varepsilon_2, \ldots \). It is the limit of \( Next^1 0, Next^2 0, Next^3 0, ... \) which is \( Next^\omega 0 \).

More generally, we have \( \varepsilon_\alpha = \varphi(1,\alpha) = Next^{1+\alpha} 0 = Next^{1+\alpha} \omega \).

\bigskip

\( \zeta_0 = \varphi(2,0) \) is the least fixed point of \( \alpha \mapsto \varepsilon_\alpha \) (greater than 0), so \( \zeta_0 = Fix (\alpha \mapsto \varepsilon_\alpha) 0 = Fix (\alpha \mapsto Next^{1+\alpha} 0) 0 = Fix (\alpha \mapsto Next^\alpha 0) 0 \) (because the "1+" is "absorbed" after a few iterations) \( = [0] Next\ 0 \). Since \( \zeta_0 \) is also greater than \( \omega \), it is also \( [0] Next\ \omega \) according to a similar computation. 

\( \zeta_1 = \varphi(2,1) \) is the next fixed point of \( \alpha \mapsto \varepsilon_\alpha \), the least one which is strictly greater than \( \zeta_0 \), so \( \zeta_1 = Fix (\alpha \mapsto \varepsilon_\alpha) \zeta_0 = Fix (\alpha \mapsto Next^\alpha 0) \zeta_0 = [0] Next\ \zeta_0 = [0] Next ([0] Next\ 0) = ([0] Next)^2 0 \).

More generally, \( \zeta_\alpha = ([0] Next)^{1+\alpha} 0 \).

Similar computations give \( \eta_0 = \varphi(3,0) = [0]^2 Next\ 0 \) and \( \eta_\alpha = ([0]^2 Next)^{1+\alpha} 0 \).

More generally, \( \varphi(1+\beta,\alpha) = ([0]^\beta Next)^{1+\alpha} 0 \) or \( ([0]^\beta Next)^{1+\alpha} \omega \).

\bigskip

\( \Gamma_0 = \varphi(1,0,0) \) is the least fixed point (greater than 0) of the function \( \alpha \mapsto \varphi(\alpha,0) \) or \( \alpha \mapsto \varphi(1+\alpha,0) \) (for the same reason of "absorbsion" of "1+" than previously), so \( \Gamma_0 = Fix (\alpha \mapsto \varphi(1+\alpha,0) 0 = Fix (\alpha \mapsto ([0]^\alpha Next)^(1+0) 0) 0 = Fix (\alpha \mapsto [0]^\alpha Next\ 0) 0 = [1] [0] Next\ 0 \).

\( \Gamma_1 = \varphi(1,0,1) \) is the next fixed point : \( \Gamma_1 = Fix (\alpha \mapsto [0]^\alpha Next\ 0) \Gamma_0 = [1] [0] Next\ \Gamma_0 = [1] [0] Next\ ([1] [0] Next\ 0) = ([1] [0] Next)^2 0 \).

More generally, we have \( \varphi(1,0,\alpha) = ([1] [0] Next)^{1+\alpha} 0 \).

\( \varphi(1,1,0) \) is the least fixed point (greater than 0) of the function \( \alpha \mapsto \varphi(1,0,\alpha) \), so it is \( Fix (\alpha \mapsto \varphi(1,0,\alpha)) 0 = Fix (\alpha \mapsto ([1] [0] Next)^{1+\alpha} 0) 0 = Fix (\alpha \mapsto ([1] [0] Next)^{\alpha} 0) 0 \) (absorbsion of 1+) \( = [0] ([1] [0] Next) 0 \).

\( \varphi(1,1,1) \) is the next fixed point \( Fix (\alpha \mapsto ([1] [0] Next)^{\alpha} 0) \varphi(1,1,0) = ([0] ([1] [0] Next) ([0] ([1] [0] Next) 0) = ([0] ([1] [0] Next))^2 0 \).

More generally, \( \varphi(1,1,\alpha) = ([0] ([1] [0] Next))^{1+\alpha} 0 \).

\( \varphi(1,2,0) \) is the least fixed point (greater than 0) of the function \( \alpha \mapsto \varphi(1,1,\alpha), Fix (\alpha \mapsto \varphi(1,1,\alpha)) 0 = Fix ([0] ([1] [0] Next)^{1+\alpha} 0) 0 = Fix (\alpha \mapsto ([0] ([1] [0] Next))^\alpha 0) 0 = [0] ([0] ([1] [0] Next)) 0 = [0]^2 ([1] [0] Next) 0 \).

Like previously, \( \varphi(1,2,\alpha) \) is the \( (1+\alpha) \)-th fixed point of the previous function, which is \( ([0]^2 ([1] [0] Next))^{1+\alpha} 0 \).

More generally, \( \varphi(1,\beta,\alpha) = ([0]^\beta ([1] [0] Next))^{1+\alpha} 0 \).

\( \varphi(2,0,0) \) is the least fixed point (greater than 0) of the function \( \beta \mapsto \varphi(1,\beta,0) \), which is \( Fix (\alpha \mapsto \varphi(1,\beta,0)) 0 = Fix (\beta \mapsto ([0]^\beta ([1] [0] Next))^{1+0} 0) 0 = Fix (\beta \mapsto [0]^\beta ([1] [0] Next) 0) 0 = [1] [0] ([1] [0] Next) 0 = ([1] [0])^2 Next\ 0 \).

The \( (1+\alpha) \)-th fixed point of the previous function is \( \varphi(2,0,\alpha) = (([1] [0])^2 Next)^{1+\alpha} 0 \).

The least fixed point of the function \( \alpha \mapsto \varphi(2,0,\alpha) \) is \( \varphi(2,1,0) = Fix (\alpha \mapsto \varphi(2,0,\alpha)) 0 = Fix (\alpha \mapsto (([1] [0])^2 Next)^(1+\alpha) 0) 0 = Fix (\alpha \mapsto (([1] [0])^2 Next)^\alpha 0) = [0] (([1] [0])^2 Next) 0 \) and its \( (1+\alpha) \)-th fixed point is \( \varphi(2,1,\alpha) = ([0] (([1] [0])^2 Next))^{1+\alpha} 0 \).

More generally, we have \( \varphi(2,\beta,\alpha) = ([0]^\beta (([1] [0])^2 Next))^{1+\alpha} 0 \).

\bigskip

The general formula with three variables (with \( \gamma \neq 0 \) ) is \( \varphi(\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma Next))^{1+\alpha} 0 \).

In particular, we have \( \varphi(\gamma,0,0) = ([1] [0])^\gamma Next 0 \).

\bigskip

\( \varphi(1,0,0,0) \) is the least fixed point of the function \( \gamma \mapsto \varphi(\gamma,0,0), Fix (\gamma \mapsto \varphi(\gamma,0,0)) 0 = Fix (\gamma \mapsto ([1] [0])^\gamma Next\ 0) 0 = [1] ([1] [0]) Next\ 0 = [1]^2 [0] Next\ 0 \).

All of these computations could be done with \( \omega \) instead of 0 at the end of the formulas so we also have \( \varphi(\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma Next))^{1+\alpha} \omega \).

In a similar way, we can obtain the formula with 4 variables :

\( \varphi(1,0,0,\alpha) = ([1]^2 [0] Next)^{1+\alpha} 0 \)

\( \varphi(1,0,1,0) = Fix (\alpha \mapsto ([1]^2 [0] Next)^\alpha 0) 0 = [0] ([1]^2 [0]) 0 \)

\( \varphi (1,0,1,\alpha) = ([0] ([1]^2 [0] Next))^{1+\alpha} 0 \)

\( \varphi(1,0,\beta,\alpha) = ([0]^\beta ([1]^2 [0] Next))^{1+\alpha} 0 \)

\( \varphi(1,1,0,0) = Fix (\alpha \mapsto \varphi(1,0,\alpha,0)] 0 = Fix (\alpha \mapsto [0]^\alpha ([1]^2 [0] Next) 0] 0 = [1] [0] ([1]^2 [0] Next) 0 \)

\( \varphi(1,1,0,\alpha) = ([1] [0] ([1]^2 [0] Next))^{1+\alpha} 0 \)

\( \varphi(1,1,1,0) = Fix (\alpha \mapsto \varphi(1,1,0,\alpha)) 0 = Fix (\alpha \mapsto ([1] [0] ([1]^2 [0] Next))^\alpha 0) 0 = [0] ([1] [0] ([1]^2 [0] Next)) 0 \)

\( \varphi(1,1,1,\alpha) = ([0] ([1] [0] ([1]^2 [0] next)))^{1+\alpha} 0 \)

\( \varphi(1,1,\beta,\alpha) = ([0]^\beta ([1] [0] ([1]^2 [0] Next)))^{1+\alpha} 0 \)

\( \varphi(1,2,0,0) = Fix (\alpha \mapsto \varphi(1,1,\alpha,0)) 0 = Fix (\alpha \mapsto [0]^\alpha ([1] [0] ([1]^2 [0] next)) 0) 0 = [1] [0] ([1] [0] ([1]^2 [0] Next)) 0 = ([1] [0])^2 ([1]^2 [0] Next) 0 \)

\( \varphi(1,0,0,0) = [1]^2 [0] Next 0 \)

\( \varphi(1,1,0,0) = [1] [0] ([1]^2 [0] Next) 0 \)

\( \varphi(1,2,0,0) = ([1] [0])^2 ([1]^2 [0] Next) 0 \)

\( \varphi(1,\gamma,0,0) = ([1] [0])^\gamma ([1]^2 [0] Next) 0 \)

\( \varphi(1,\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma ([1]^2 [0] Next)))^{1+\alpha} 0 \)

\( \varphi(2,0,0,0) = Fix (\alpha \mapsto \varphi(1,\alpha,0,0)] 0 = Fix (\alpha \mapsto ([1] [0])^\alpha ([1]^2 [0] Next) 0] 0 = [1] ([1] [0]) ([1]^2 [0] Next) 0 = [1]^2 [0] ([1]^2 [0] Next) 0 = ([1]^2 [0])^2 Next 0 \)

\( \varphi(\delta,0,0,0) = ([1]^2 [0])^\delta Next\ 0 \)

The general formula with four variables is : 

\( \varphi(\delta,\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma (([1]^2 [0])^\delta Next)))^{1+\alpha} 0 = ([0]^\beta (([1] [0])^\gamma (([1]^2 [0])^\delta Next)))^{1+\alpha} \omega \) 

and so on.

\bigskip

The small Veblen ordinal is the limit of :

 \( \varphi(1) = \omega, \varphi(1,0) = Next\ \omega, \varphi(1,0,0) = [1] [0] Next\ \omega, \varphi(1,0,0,0) = [1]^2 [0] Next\ \omega, \varphi(1,0,0,0,0) = [1]^3 [0] Next\ \omega, \ldots \). 

This limit is \( [1]^\omega [0] Next\ \omega = [1]^\omega [0] Next\ 0 \).

\bigskip

Allowing variables at any finite or transfinite positions (which is equivalent to Schütte brackets or Klammersymbols) gives ordinals smaller than the large Veblen ordinal which is \( [2] [1] [0] Next\ 0 \) or \( [2] [1] [0] Next\ \omega \). 

The conversion rule from Schütte Klammersymbol to Simmons notation are described by Simmons in his paper : http://www.cs.man.ac.uk/~hsimmons/ORDINAL-NOTATIONS/FromBelow.pdf (Simmons also wrote other papers but it seems to me that they contain inaccuracies and maybe even errors).

In summary :

\( Fix\ f \zeta = f^\omega (\zeta+1) \)

\( Enm\ h\ \alpha = h^{1+\alpha} 0 \)

\( Next = Fix (\alpha \mapsto \omega^\alpha) \)

\( [0] h = Fix (\alpha \mapsto h^\alpha 0) \)

\( [1] h g = Fix (\alpha \mapsto h^\alpha g 0) \)

\( \nabla \begin{bmatrix} \alpha+1 \\
                                    i+1      \end{bmatrix} =
 ([1]^i [0])^{1+\alpha} \) if \( i \neq 0 ; [0]^\alpha \) if \( i = 0 \)

\( \nabla \begin{bmatrix} \alpha_1+1 & \ldots & \alpha_s+1 \\
                                    i_1+1      & \ldots & \i_s+1     \end{bmatrix} 
= \nabla \begin{bmatrix} \alpha_1+1 \\
                                   i_1+1      \end{bmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                    i_s+1      \end{bmatrix}
\)

where \( f \circ g \) is the composition of functions f and g : \( (f \circ g) x = f\ (g\ x) \)

\( Sch \begin{bmatrix} 1+\alpha_1 & \ldots & 1+\alpha_s \\
                       1+i_1      & \ldots & 1+i_s      \end{bmatrix} 
= Enm\ \circ \nabla \begin{bmatrix} 1+\alpha_1 & \ldots & 1+\alpha_s \\
                                          1+i_1      & \ldots & 1+i_s      \end{bmatrix} o\ Fix
\)


f may be any function but it is usually \( \alpha \mapsto \omega^\alpha \).

\( f \begin{pmatrix} \zeta & 1+\alpha_1 & \ldots & 1+\alpha_s \\
                     0     & 1+i_1      & \ldots & 1+i_s      \end{pmatrix} \)

\( = Sch \begin{bmatrix} 1+\alpha_1 & \ldots & 1+\alpha_s \\
                      1+i_1      & \ldots & 1+i_s      \end{bmatrix} f \zeta \)

\( = (Enm \circ \nabla \begin{bmatrix} 1+\alpha_1 & \ldots & 1+\alpha_s \\
                                       1+i_1      & \ldots & 1+i_s      \end{bmatrix} \circ Fix) f \zeta \)

\( = (Enm \circ \nabla \begin{bmatrix} \alpha_1+1 \\
                                       i_1+1      \end{bmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                              i_s+1      \end{bmatrix} \circ Fix) f \zeta \)

\( = Enm ((\nabla \begin{bmatrix} \alpha_1+1 \\
                                  i_1+1      \end{bmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                         i_s+1      \end{bmatrix}) (Fix f)) \zeta \)

\( = (\nabla \begin{bmatrix} \alpha_1+1 \\
                             i_1+1      \end{bmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                    i_s+1      \end{bmatrix}) (Fix f))^{1+\zeta} 0 \)

\bigskip

If \( f = \alpha \mapsto \omega^\alpha \), then Fix f = Next and 

\( f \begin{pmatrix} \zeta & 1+\alpha_1 & \ldots & 1+\alpha_s \\
                     0     & 1+i_1      & \ldots & 1+i_s      \end{pmatrix} 
 = (\nabla \begin{bmatrix} \alpha_1+1 \\
                             i_1+1      \end{bmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                    i_s+1      \end{bmatrix}) Next)^{1+\zeta} 0 \)

\bigskip

Examples :

\bigskip

\( \varphi(1+\beta,\alpha) \)

\( = (\xi \mapsto \omega^\xi) \begin{pmatrix} \alpha & 1+\beta \\
                                              0      & 1       \end{pmatrix} \)

\( = ((\nabla \begin{bmatrix} \beta+1 \\
                              1       \end{bmatrix}) (Fix (\xi \mapsto \omega^\xi)))^{1+\alpha} 0 \)

\( = ((\nabla \begin{bmatrix} \beta+1 \\
                              1       \end{bmatrix}) Next)^{1+\alpha} 0 \)

\( = ([0]^\beta Next)^{1+\alpha} 0 \)

\bigskip

\( \varphi(1+\gamma,1+\beta,\alpha) \)

\( = (\xi \mapsto \omega^\xi) \begin{pmatrix} \alpha & 1+\beta & 1+\gamma \\
                                              0      & 1       & 2        \end{pmatrix} \)

\( = ((\nabla \begin{bmatrix} \beta+1 \\
                              1       \end{bmatrix} \circ [0] \circ \nabla \begin{bmatrix} \gamma+1 \\
                                                                                           2        \end{bmatrix}) (Fix (\xi \mapsto \omega^\xi)))^{1+\alpha} 0 \)

\( = ((\nabla \begin{bmatrix} \beta+1 \\
                              1       \end{bmatrix} \circ [0] \circ \nabla \begin{bmatrix} \gamma+1 \\
                                                                                           2        \end{bmatrix}) Next)^{1+\alpha} 0 \)

\( = (([0]^\beta  \circ [0] \circ ([1] [0])^{1+\gamma}) Next)^{1+\alpha} 0 \)

\( = ([0]^{1+\beta} (([1] [0])^{1+\gamma} Next))^{1+\alpha} 0 \)

Compare with the previously found formula :

if \( \gamma > 0, \varphi(\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma Next))^{1+\alpha} 0 \)

and note the "round trip" \( 1+\gamma \rightarrow \gamma+1 \rightarrow 1+\gamma \).

\bigskip

\( \varphi(1+\delta,1+\gamma,1+\beta,\alpha) \)

\( = (\xi \mapsto \omega^\xi) \begin{pmatrix} \alpha & 1+\beta & 1+\gamma & 1+\delta \\
                                              0      & 1       & 2        & 3        \end{pmatrix} \)

\( = ((\nabla \begin{bmatrix} \beta+1 \\
                              1       \end{bmatrix} \circ [0] \circ \nabla \begin{bmatrix} \gamma+1 \\
                                                                                           2        \end{bmatrix} \circ [0] \circ \nabla \begin{bmatrix} \delta+1 \\
                                                                                                                                                         3        \end{bmatrix}) (Fix (\xi \mapsto \omega^\xi)))^{1+\alpha} 0 \)

\( = ((\nabla \begin{bmatrix} \beta+1 \\
                              1       \end{bmatrix} \circ [0] \circ \nabla \begin{bmatrix} \gamma+1 \\
                                                                                           2        \end{bmatrix} \circ [0] \circ \nabla \begin{bmatrix} \delta+1 \\
                                                                                                                                                         3        \end{bmatrix}) Next)^{1+\alpha} 0 \)

\( = (([0]^\beta \circ [0] \circ ([1] [0])^{1+\gamma} \circ [0] \circ ([1]^2 [0])^{1+\delta}) Next)^{1+\alpha} 0 \)

\( = ([0]^{1+\beta} (([1] [0])^{1+\gamma} ([0] (([1]^2 [0])^{1+\delta} Next))))^{1+\alpha} 0 \)

\( = ([0]^{1+\beta} (([1] [0])^{1+\gamma} (([1]^2 [0])^{1+\delta} Next)))^{1+\alpha} 0 \) 

because [0] is absorbed by the following operator (see http://www.cs.man.ac.uk/~hsimmons/ORDINAL-NOTATIONS/FromBelow.pdf p 33, 6.7)

Compare with the previously mentioned formula :

\( \varphi(\delta,\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma (([1]^2 [0])^\delta Next)))^{1+\alpha} 0 \)

\bigskip

The equality

\( (\xi \mapsto \omega^\xi) \begin{pmatrix} \zeta & 1+\alpha_1 & \ldots & 1+\alpha_s \\
                                            0     & 1+i_1      & \ldots & 1+i_s      \end{pmatrix} 
 = (\nabla \begin{bmatrix} \alpha_1+1 \\
                             i_1+1      \end{bmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                    i_s+1      \end{bmatrix}) Next)^{1+\zeta} 0 \)

can be reformulated, distinguishing four cases :

\begin{itemize}

\item 
\( (\xi \mapsto \omega^\xi) \begin{pmatrix} \zeta \\
                                            0     \end{pmatrix} = \varphi(0,\zeta) = \omega^\zeta \)

\item 
\( (\xi \mapsto \omega^\xi) \begin{pmatrix} \zeta & 1+\alpha \\
                                            0     & 1        \end{pmatrix} = \varphi(1+\alpha,\zeta) 
= (\nabla \begin{bmatrix} \alpha+1 \\
                          1        \end{bmatrix} Next)^{1+\zeta} 0 = ([0]^\alpha Next)^{1+\zeta} 0 \)

\item 
\( (\xi \mapsto \omega^\xi) \begin{pmatrix} \zeta & 1+\alpha_1 & 1+\alpha_2 & \ldots & 1+\alpha_s \\
                                                  0     & 1          & 1+i_2      & \ldots & 1+i_s      \end{pmatrix} \)

\( = ((\nabla \begin{bmatrix} \alpha_1+1 \\
                              1          \end{bmatrix} \circ [0] \circ \nabla \begin{pmatrix} \alpha_2+1 \\
                                                                                              i_2+1      \end{pmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                                                                                     i_s+1      \end{bmatrix}) Next)^{1+\zeta} 0 \)

\( = (([0]^{\alpha_1} \circ [0] \circ ([1]^{i_2} [0])^{1+\alpha_2} \circ [0] \circ \ldots \circ [0] \circ ([1]^{i_s} [0])^{1+\alpha_s}) Next)^{1+\zeta} 0 \) 

\( = (([0]^{1+\alpha_1} \circ ([1]^{i_2} [0])^{1+\alpha_2} \circ [0] \circ \ldots \circ [0] \circ ([1]^{i_s} [0])^{1+\alpha_s}) Next)^{1+\zeta} 0 \)

\( = (([0]^{1+\alpha_1} \circ ([1]^{i_2} [0])^{1+\alpha_2} \circ \ldots \circ ([1]^{i_s} [0])^{1+\alpha_s}) Next)^{1+\zeta} 0 \)

The first separating [0] is combined with \( [0]^{\alpha_1} \) giving \( [0]^{1+\alpha_1} \) and the other are absorbed.

\item
\( (\xi \mapsto \omega^\xi) \begin{pmatrix} \zeta & 1+\alpha_1 & \ldots & 1+\alpha_s \\
                                            0     & 1+i_1      & \ldots & 1+i_s      \end{pmatrix} \) with \( i_1 \neq 0 \)

\( = ((\nabla \begin{bmatrix} \alpha_1+1 \\
                              i_1+1      \end{bmatrix} \circ [0] \circ \ldots \circ [0] \circ \nabla \begin{bmatrix} \alpha_s+1 \\
                                                                                                                     i_s+1      \end{bmatrix}) Next)^{1+\zeta} 0 \)

\( = ((([1]^{i_1} [0])^{1+\alpha_1} \circ [0] \circ \ldots \circ [0] \circ ([1]^{i_s} [0])^{1+\alpha_s}) Next)^{1+\zeta} 0 \) 

\( = ((([1]^{i_1} [0])^{1+\alpha_1} \circ \ldots \circ ([1]^{i_s} [0])^{1+\alpha_s}) Next)^{1+\zeta} 0 \) 

The separating [0] are absorbed.

\end{itemize}

We can see that the third case is contained in the fourth one if we remove the restriction \( i_1 \neq 0 \) because if \( i_1 = 0 \) we have \( ([1]^{i_1} [0])^{1+\alpha_1} = [0]^{1+\alpha_1} \) like in the third case.


\bigskip



For more information concerning the correspondence between Simmons notation and Schütte Klammersymbols, see :

http://www.cs.man.ac.uk/~hsimmons/ORDINAL-NOTATIONS/FromBelow.pdf pages 28 - 34.

\bigskip

The limit of Next 0, [0] Next 0, [1] [0] Next 0, [2] [1] [0] Next 0, [3] [2] [1] [0] Next 0, ... 

or \( Next\ \omega, [0] Next\ \omega, [1] [0] Next\ \omega, [2] [1] [0] Next\ \omega, [3] [2] [1] [0] Next\ \omega, \ldots \) 

is called the Bachmann-Howard ordinal (BHO). 

It could be written \( [\omega \ldots 0] Next\ 0 \) or \( [\omega \ldots 0] Next\ \omega \).


\section{Rationalization of the Veblen functions}

When we have defined the different notations, we have arbitrarily chosen some conventions, for example the limit of \( \omega, \omega^\omega, \omega^{\omega^\omega}, \ldots \) have been called  \( \varepsilon_0 \). We could have called it \( \varepsilon_1 \). In this case, \( \varepsilon_\alpha \) would have been the \( \alpha \)-th fixed point of \( \xi \mapsto \omega^\xi \) instead of the the \( (1+\alpha) \)-th one. Also we chose to define \( \varphi(0,\alpha) = \omega^\alpha \). We could have chosen to define \( \varphi(0,\alpha) = \varepsilon_\alpha \). The "1+" which appear in the correspondence between Simmons and Veblen notations may be due to the fact that the choices that have been made are not the most logical. 

We will define a rationalized variant of the Veblen notations which simplifies the correspondence with the Simmons notation :

\begin{itemize}

\item \( \varepsilon_\alpha = \varphi(1,\alpha) = \varepsilon'_{1+\alpha} = \varphi'(0,1+\alpha) \)

\item \( \zeta_\alpha = \varphi(2,\alpha) = \zeta'_{1+\alpha} = \varphi'(1,1+\alpha) \)

\item \( \eta_\alpha = \varphi(3,\alpha) = \eta'_{1+\alpha} = \varphi'(2,1+\alpha) \)

\item Generally, \( \varphi(1+\beta,\alpha) = \varphi'(\beta,1+\alpha) \)

\item \( \Gamma_0 = \varphi(1,0,0) = \varphi'(1,0,1) \)

\item Generally, if \( \gamma \neq 0, \varphi(\gamma,\beta,\alpha) = \varphi'(\gamma,\beta,1+\alpha) \)

\item In a similar way, if \( \gamma \neq 0 \) or \( \delta \neq 0, \varphi(\delta,\gamma,\beta,\alpha) = \varphi'(\delta,\gamma,\beta,1+\alpha) \) and so on.

\end{itemize}

With this notation, the correspondence with Simmons notation becomes simpler, for example we have :

\begin{itemize}

\item 
\( \varepsilon'_\alpha = Next^\alpha 0 \) instead of \( \varepsilon_\alpha = Next^{1+\alpha} 0 \)

\item
\( \varphi'(\beta,\alpha) = ([0]^\beta Next)^\alpha 0 \) 
instead of
\( \varphi(1+\beta,\alpha) = ([0]^\beta Next)^{1+\alpha} 0 \) 

\item
\( \varphi'(\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma Next))^\alpha 0 \)
instead of 
\( \varphi(\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma Next))^{1+\alpha} 0 \)

\item
\( \varphi'(\delta,\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma (([1]^2 [0])^\delta Next)))^{1+\alpha} 0  \) 
instead of 
\( \varphi(\delta,\gamma,\beta,\alpha) = ([0]^\beta (([1] [0])^\gamma (([1]^2 [0])^\delta Next)))^{1+\alpha} 0  \) 

\end{itemize}

\section{RHS0 notation}



\section{Collapsing functions}



\section{Summary}

Any ordinal can be defined as the least ordinal strictly greater than all ordinals of a set : the empty set for 0, \(\lbrace \alpha \rbrace\) for the successor of \( \alpha \),  \(\lbrace \alpha_0,\alpha_1,\alpha_2,...\rbrace\) for an ordinal with fundamental sequence \(\alpha_0, \alpha_1, \alpha_2, ...\)

\vspace{-0.7cm}

\section{Algebraic notation}
\vspace{-0.4cm}
We define the following operations on ordinals :
\vspace{-0.4cm}
\smallskip
\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}
\item addition : \( \alpha+0=\alpha ; \alpha+suc(\beta)=suc(\alpha+\beta); \alpha+lim(f)=lim(n \mapsto \alpha+f(n)) \)
\vspace{-0.1cm}
\item multiplication : \( \alpha \times 0 = 0 ; \alpha \times suc(\beta) = (\alpha \times \beta) + \alpha ; \alpha \times lim(f) = lim (n \mapsto \alpha \times f(n)) \)
\vspace{-0.1cm}
\item exponentiation : \( \alpha^0 = 1 ; \alpha^{suc(\beta)} = \alpha^\beta \times \alpha ; \alpha^{lim(f)} = lim (n \mapsto \alpha^{f(n)}) \)
\end{itemize}
\vspace{-0.8cm}

\section{Veblen functions}
\vspace{-0.4cm}
These functions use fixed points enumaration : \(\varphi(\ldots,\beta,0,\ldots,0,\gamma) \) represents the \((1+\gamma)^{th}\) common fixed point of the functions \( \xi \mapsto \varphi(\ldots,\delta,\xi,0,\ldots,0)\) for all \(\delta < \beta\).
\vspace{-0.6cm}

\section{Simmons notation}
\vspace{-0.4cm}
\( Fix f z = f^w(z+1)\) = least fixed point of f strictly greater than z.

\( Next = Fix (\alpha \mapsto \omega^\alpha) \) 

\( [0] h = Fix (\alpha \mapsto h^\alpha \omega) \) ;
\( [1] h g = Fix (\alpha \mapsto h^\alpha g \omega) \) ;
\( [2] h g f = Fix (\alpha \mapsto h^\alpha g f \omega) \) ; etc...

Correspondence with Veblen's \(\phi\) : \( \phi(1+\alpha,\beta) = ([0]^\alpha Next)^{1+\beta} \omega ; 
 \phi(\alpha,\beta,\gamma) = ([0]^\beta (([1] [0])^\alpha Next))^{1+\gamma} \omega \)


\vspace{-0.6cm}

\section{RHS0 notation}
\vspace{-0.4cm}
We start from 0, if we don(t see any regularity we take the successor, if we see a regularity, if we have a notation for this regularity, we use it, else we invent it, then we jump to the limit.

\( H f x = lim\ x, f x, f (f x), \ldots ; R_1 f g x = lim\ g x, f g x, f f g x, \ldots ; R_2 f g h x = lim\ h x, f g h x, f g f g h x, \ldots \)

Correspondence with Simmons notation : 
\( \ldots, [3] \rightarrow R5, [2] \rightarrow R4, [1] \rightarrow R3, [0] \rightarrow R2, Next \rightarrow R1, \omega \rightarrow H suc\ 0 \)

\vspace{-0.6cm}

\section{Ordinal collapsing functions}
\vspace{-0.4cm}
These functions use uncountable ordinals to define countable ordinals.

We define sets of ordinals that can be built from given ordinals and operations, then we take the least ordinal which is not in this set, or the least ordinal which is greater than all contable ordinals of this set.

These functions are extensions of functions on countable ordinals, whose fixed points can be reached by applying them to an uncountable ordinal.

Examples :
\vspace{-0.4cm}
\smallskip
\begin{itemize}
     \setlength{\itemsep}{1pt}
     \setlength{\parskip}{0pt}
     \setlength{\parsep}{0pt}
\item Madore's \(\psi\) : \(\psi(\alpha) = \varepsilon_\alpha \) if \(\alpha < \zeta_0 ; \psi(\Omega) = \zeta_0 \) which is the least fixed point of \( \alpha \mapsto \varepsilon_\alpha \).
\vspace{-0.1cm}
\item Feferman's \(\theta\) : \(\theta(\alpha,\beta) = \varphi(\alpha,\beta) \) if \( \alpha < \Gamma_0 \) and \( \beta < \Gamma_0 ; \theta(\Omega,0) = \Gamma_0 \) which is the least fixed point of \( \alpha \mapsto \varphi(\alpha,0) \).
\vspace{-0.1cm}
\item Taranovsky's C : \( C(\alpha,\beta) = \beta+\omega^\alpha \) if \( \alpha \) is countable; \( C(\Omega_1,0) = \varepsilon_0 \) which is the least fixed point of \( \alpha \mapsto \omega^\alpha \).
\end{itemize}

\vspace{0.1cm}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
Nom		& Symbole		& Algebraic			& Veblen			& Simmons			& RHS0 		& Madore				& Taranovsky 			\\
\hline
Zero		& 0			& 0				& 				& 				& 0			& 					& 0				\\ \hline
One		& 1			& 1				& \(\varphi(0,0)\)		& 				& suc 0			& 					& C(0,0)			\\ \hline
Two		& 2			& 2				& 				& 				& suc (suc 0)		& 					& C(0,C(0,0))			\\ \hline
Omega		& \(\omega\)		& \(\omega\)			& \(\varphi(0,1)\)		& \(\omega\)			& H suc 0		& 					& C(1,0)			\\ \hline
		& 			& \(\omega+1\)			& 				& 				& suc (H suc 0)		& 					& C(0,C(1,0))			\\ \hline
		&			& \(\omega\times2\)		&				& 				& H suc (H suc 0)	& 					& C(1,C(1,0))			\\ \hline
		&			& \(\omega^2\)			& \(\varphi(0,2)\)		& 				& H (H suc) 0		& 					& C(C(0,C(0,0)),0)		\\ \hline
		&			& \(\omega^\omega\)		& \(\varphi(0,\omega)\)		& 				& H H suc 0		& 					& C(C(1,0),0)			\\ \hline
		&			& \(\omega^{\omega^\omega}\)	& \(\varphi(0,\omega^\omega)\)	&				& H H H suc 0		&					& C(C(C(1,0),0),0)		\\ \hline
Epsilon zero	& \(\varepsilon_0\)	& \(\varepsilon_0\)		& \(\varphi(1,0)\)		& \(Next\ \omega\)		& \(R_1 H suc\ 0\)	& \(\psi(0)\)				& \(C(\Omega_1,0)\)		\\ \hline
		& 			& \(\varepsilon_1\)		& \(\varphi(1,1)\)		& \(Next^2 \omega\)	& \(R_1 (R_1 H) suc\ 0\)& \(\psi(1)\)				& \(C(\Omega_1,C(\Omega_1,0)\)	\\ \hline
		& 			& \(\varepsilon_\omega\)	& \(\varphi(1,\omega)\) 	& \(Next^\omega \omega\) & \(H R_1 H suc\ 0\)	& \(\psi(\omega)\)			& \(C(C(0,\Omega_1),0)\)	\\ \hline
		& 			&\(\varepsilon_{\varepsilon_0}\)& \(\varphi(1,\varphi(1,0))\)	& \(Next^{Next \omega} \omega \) & \(R_1 H R_1 H suc\ 0\)& \(\psi(\psi(0))\)			& \(C(C(C(\Omega_1,0),\Omega_1),0)\)\\ \hline
Zeta zero	& \(\zeta_0\)		& \(\zeta_0\)			& \(\varphi(2,0)\)		& \([0] Next\ \omega\)		& \(R_2 R_1 H suc\ 0\)	& \(\psi(\Omega)\)			& \(C(C(\Omega_1,\Omega_1),0)\)	\\ \hline
Eta zero	& \(\eta_0\)		& \(\eta_0\)			& \(\varphi(3,0)\)		& \([0]^2 Next\ \omega\) 	& \(R_2 (R_2 R_1) H suc\ 0\)&					& \(C(C(\Omega,C(\Omega,\Omega)),0)\) \\ \hline
		&			&			& \(\varphi(\omega,0)\)		& \([0]^\omega Next\ \omega\) & \(H R_2 R_1 H suc\ 0\)&					& \(C(C(C(0,\Omega_1),\Omega_1),0)\) \\ \hline
Feferman	& \(\Gamma_0\)		
								& \(\Gamma_0\)			& \(\varphi(1,0,0)\)		& \([1] [0] Next\ \omega\)	& \(R_3 R_2 R_1 H suc\ 0\) & \(\psi(\Omega^\Omega)\)		& \(C(C(C(\Omega_1,\Omega_1),\) \\ 
-Schütte	&			&				& \(=\varphi(2 \mapsto 1)\)	&				& \(= R_{3 \ldots 1} H suc\ 0\) & 					& \(\Omega_1),0)\)		\\ \hline
Ackermann	&			&				& \(\varphi(1,0,0,0)\)		& \([1]^2 [0] Next\ \omega\) & \(R_3 (R_3 R_2) R_1 H suc\ 0\) & \(\psi(\Omega^{\Omega^2})\)		&				\\ 
		&			&				& \(=\varphi(3 \mapsto 1)\)	&				&			&					&				\\ \hline
Small Veblen	&			&				& \(\varphi(\omega \mapsto 1)\)	& \([1]^\omega [0] Next\ \omega\) & \(H R_3 R_2 R_1 H suc\ 0\) & \(\psi(\Omega^{\Omega^\omega})\)	& \(C(\Omega_1^\omega,0)\)	\\
ordinal		&			&				&				&				&			&					& \(=C(C(C(C(0,\Omega_1), \)	\\ 
		&			&				&				&				&			&					& \(\Omega_1),\Omega_1),0)\)	\\ \hline
Large Veblen	&			&				& least ord.	 	 	& \([2] [1] [0] Next\ \omega\)	& \(R_4 R_3 R_2 R_1 H suc\ 0\) & \(\psi(\Omega^{\Omega^\Omega})\)	& \(C(\Omega_1^{\Omega_1},0)\)	\\
ordinal		&			&				& not rep.			&				& \(= R_{4 \ldots 1} H suc\ 0\) &					& \(=C(C(C(C(\Omega_1,\Omega_1),\) \\ 
		&			&				&				&				&			&					& \( \Omega_1),\Omega_1),0) \)	\\ \hline
Bachmann-	&			&				&				& least ord.			& \(R_{\omega \ldots 1} H suc\ 0\) & \(\psi(\varepsilon_{\Omega+1})\)	& \(C(C(\Omega_2,\Omega_1),0)\)	\\
Howard		&			&				&				& not rep.			&			&					&				\\ 
ordinal		&			&				&				&				&			&					&				\\ \hline
  
\end{tabular}


\end{document}

